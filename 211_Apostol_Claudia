///trebuie activat al doilea compiler flag( have g++ follow C++11 ISO C++ language standard [-std=c++11]
#include <iostream>
#include <vector>
#include <stdlib.h>
#include <typeinfo>
#include <utility>
#include <bits/stdc++.h>
using namespace std;

class locuinta
{
protected:
    string numeclient;
    double supraf;
    double discount;
    static int nrloc;
public:
    static void locuinte()
    {
        cout<<"S-au creat "<<nrloc<<" locuinte"<<endl;
    }
    int ret_nrloc()
    {
        return nrloc;
    }
    locuinta(string nume="",double s=0,double di=0)
    {
        numeclient=nume;
        try
        {
            if (s<0)
                throw s;
        }
        catch (double x)
        {
            cout<<"Eroare in constructor, suprafata trebuie sa fie pozitiva"<<endl;
            exit(EXIT_FAILURE);
        }
        supraf=s;
        try
        {
            if (di<0||di>10)
                throw di;
        }
        catch (double x)
        {
            cout<<"Eroare in constructor, disconutul trebuie sa fie intre 0-10%"<<endl;
            exit(EXIT_FAILURE);
        }
        discount=di;
        nrloc++;
    }
    virtual ~locuinta()
    {

    }
    virtual void citire(istream& in)
    {
        cout<<"Introduceti numele clientului: ";
        getline(in,numeclient);
        cout<<"Introduceti suprafata locuintei: ";
        double s;
        in>>s;
        try
        {
            if (s<0)
                throw s;
        }
        catch (double x)
        {
            cout<<"Suprafata trebuie sa fie pozitiva"<<endl;
            exit(EXIT_FAILURE);
        }
        supraf=s;
        double di;
        cout<<"Introduceti discountul(0-10%): ";
        in>>di;
        try
        {
            if(di<0 ||di>10)
                throw di;
        }
        catch(double x)
        {
            cout<<"Discount-ul trebuie sa fie intre 0-10%"<<endl;
            exit(EXIT_FAILURE);
        }
        discount=di;
    }
    virtual void afisare(ostream& out)
    {
        out<<endl<<"Nume client: "<<numeclient<<endl;
        out<<"Suprafata locuintei: "<<supraf<<endl;
        out<<"Discount: "<<discount<<endl;

    }
    friend istream& operator>>(istream&in, locuinta& l)
    {
        l.citire(in);
        return in;
    }
    friend ostream& operator<<(ostream& out,locuinta& l)
    {
        l.afisare(out);
        return out;
    }
    locuinta& operator=(locuinta& l)
    {
        this->numeclient=l.numeclient;
        this->discount=l.discount;
        this->supraf=l.supraf;
        return *this;
    }
    locuinta( locuinta* const& l)
    {
        numeclient=l->numeclient;
        discount=l->discount;
        supraf=l->supraf;
        nrloc++;
    }
    virtual double chirie()
    {
    }

};
int locuinta::nrloc;
//typedef pair<locuinta, string> pairs;

class apartament: public locuinta
{
protected:
    int etaj;
    double pret;
public:
    apartament(string nume="",double sup=0,double d=0,int e=0, double pr=0):locuinta(nume,sup,d)
    {
         try
        {
            if (e<0||e>10)
                throw e;
        }
        catch (double x)
        {
            cout<<"Eroare in constructor, etajul trebuie sa fie intre 0-10"<<endl;
            exit(EXIT_FAILURE);
        }
        etaj=e;
         try
        {
            if (pr<0)
                throw pr;
        }
        catch (double x)
        {
            cout<<"Eroare in constructor,pretul trebuie sa fie pozitiv"<<endl;
            exit(EXIT_FAILURE);
        }

        pret=pr;
    }
    ~apartament()
    {

    }

    void citire(istream& in)
    {
        locuinta::citire(in);

            cout<<"Introduceti etajul: ";
            int et;
            in>>et;
              try
        {
            if (et<0||et>10)
                throw et;
        }
        catch (int x)
        {
            cout<<"Etajul trebuie sa fie intre 0-10"<<endl;
            exit(EXIT_FAILURE);
        }
        etaj=et;

        cout<<"Introduceti pretul pe metru patrat: ";
        double pr;
        in>>pr;
          try
        {
            if (pr<0)
                throw pr;
        }
        catch (double x)
        {
            cout<<"Pretul trebuie sa fie pozitiv"<<endl;
            exit(EXIT_FAILURE);
        }
        pret=pr;

    }
    void afisare(ostream& out)
    {
        locuinta::afisare(out);
        out<<"Etaj: "<<etaj;
        out<<endl<<"Pret pe metru patrat: "<<pret;
        out<<endl<<"Chiria pentru apartament: "<<chirie(*this);
    }
    friend istream& operator>>(istream&in, apartament& l)
    {
        l.citire(in);
        return in;
    }
    friend ostream& operator<<(ostream& out,apartament& l)
    {
        l.afisare(out);
        return out;
    }
    apartament& operator=(apartament& a)
    {
        this->locuinta::operator=(a);
        this->etaj=a.etaj;
        this->pret=a.pret;
        return *this;
    }
    apartament(const apartament& a):locuinta(a)
    {
        ///cout<<"copy apartament";
        if(this!=&a)
        {
            etaj=a.etaj;
            pret=a.pret;
        }

    }
    double chirie(apartament &a)
    {
        double aux=a.pret*a.supraf;
        if(a.discount!=0)
            aux=aux-(aux*a.discount)/100;
        return aux;
    }
};
class casa: public locuinta
{
protected:
    double curte;
    int nretaje;
    double pret;
    vector <double> etaj;
public:
    casa(string nume="",double sup=0,double d=0,double c=0,int nr=0,double pr=0,vector <double> et= {}):locuinta(nume,sup,d)
    {
          try
        {
            if (c<0)
                throw c;
        }
        catch (double x)
        {
            cout<<"Eroare in constructor, suprafata curtii trebuie sa fie pozitiva"<<endl;
            exit(EXIT_FAILURE);
        }
        curte=c;
         try
        {
            if (pr<0)
                throw pr;
        }
        catch (double x)
        {
            cout<<"Eroare in constructor,pretul trebuie sa fie pozitiv"<<endl;
            exit(EXIT_FAILURE);
        }

        pret=pr;
          try
        {
            if (nr<0||nr>10)
                throw nr;
        }
        catch (int x)
        {
            cout<<"Eroare in constructor, numarul de etaje trebuie sa fie intre 0-10"<<endl;
            exit(EXIT_FAILURE);
        }
        nretaje=nr;
        if(nretaje!=0)
            for(int i=0;i<nretaje;i++)
        {
            double aux;
        try
        {
            if (aux<0)
                throw aux;
        }
        catch (double x)
        {
            cout<<"Eroare in constructor,suprafata unui etaj trebuie sa fie pozitiva"<<endl;
            exit(EXIT_FAILURE);
        }
        etaj[i]=et[i];
        }

    }
    ~casa()
    {
        delete &etaj;
    }
    casa(const casa& c):locuinta(c)
    {
        if(this!=&c)
        {
            //cout<<"Copy casa";
            curte=c.curte;
            nretaje=c.nretaje;
            pret=c.pret;
            etaj=c.etaj;
        }
    }
    casa& operator=(casa& c)
    {
        this->locuinta::operator=(c);
        this->curte=c.curte;
        this->nretaje=c.nretaje;
        this->pret=c.pret;
        this->etaj=c.etaj;
        return *this;
    }
    void citire(istream& in)
    {
        locuinta::citire(in);
        cout<<"Introduceti suprafata curtii: ";
        double c;
        in>>c;
         try
        {
            if (c<0)
                throw c;
        }
        catch (double x)
        {
            cout<<"Suprafata curtii trebuie sa fie strict pozitiva"<<endl;
            exit(EXIT_FAILURE);
        }
        curte=c;
        cout<<"Introduceti cate etaje are casa: (0= parter) ";
        int nr;
        in>>nr;
         try
        {
            if (nr<0||nr>10)
                throw nr;
        }
        catch (int x)
        {
            cout<<"Numarul de etaje trebuie sa fie intre 0-10"<<endl;
            exit(EXIT_FAILURE);
        }
        nretaje=nr;
        double aux;
        for(int i=0; i<=nretaje; i++)
        {
            ///0 etaje = doar parter
            /// sau 1 etaj = doar parter
            ///???

            cout<<"Etajul "<<i<<" are suprafata: ";
            in>>aux;
             try
        {
            if (aux<=0)
                throw aux;
        }
        catch (double x)
        {
            cout<<"Suprafata unui etaj trebuie sa fie strict pozitiva"<<endl;
            exit(EXIT_FAILURE);
        }

            etaj.push_back(aux);


        }
        cout<<"Introduceti pretul pentru metrul patrat de curte: ";
        double pr;
        in>>pr;
         try
        {
            if (pr<0)
                throw pr;
        }
        catch (double x)
        {
            cout<<"Pretul trebuie sa fie strict pozitiv"<<endl;
            exit(EXIT_FAILURE);
        }

        pret=pr;

    }
    void afisare(ostream& out)
    {
        locuinta::afisare(out);
        out<<"Suprafata curtii: "<<curte<<endl<<"Numar de etaje: "<<nretaje<<endl;
//        if(nretaje==0)
//            cout<<"Etajul 0: "<<etaj[0]<<endl;
//        else
        for(int i=0; i<=nretaje; i++)
        {
            cout<<"Etajul "<<i<<": "<<etaj[i];
            cout<<endl;
        }

        cout<<"Chiria pentru casa: "<<chirie(*this);

    }
    friend istream& operator>>(istream&in, casa& l)
    {
        l.citire(in);
        return in;
    }
    friend ostream& operator<<(ostream& out,casa& l)
    {
        l.afisare(out);
        return out;
    }
    double chirie(casa& c)
    {
        double aux=0;
//        for(int i=0;i<=nretaje;i++)
//            aux=aux+pret*etaj[i];
        aux=aux+c.supraf*c.pret;
        if(discount!=0)
            aux=aux-(aux*discount)/100;
        aux+=c.pret*c.curte;
        return aux;
    }
};
void tip(locuinta*&l, int i)
{
    cout<<endl<<"Introduceti tipul de locuinta(a/c): ";
    string aux;
    cin>>aux;
    if(aux=="c")
    {
        l=new casa;

        cin.get();
        cin>>*l;
    }
    else if(aux=="a")
    {
        l=new apartament;
        cin.get();
        cin>>*l;
    }
    else
        cout<<"Caracter invalid";
}
template <class T>
class gestiune
{
    T *vect;
    // vector <T> vect;
    int nr;
    //vector< pair<locuinta, string> > myvector;
    int index;
public:
    gestiune(T *v= {},int n=0)
    {
        nr=n;
        index=0;
        //vect=v;
        if(n>0)
        {
            vect=new T[n];
            for(int i=0; i<n; i++)
                vect[i]=v[i];
        }
    }
    gestiune(gestiune &g)
    {
        nr=g.n;
        if(nr>0)
        {
            vect=new T[nr];
            for(int i=0; i<nr; i++)
                vect[i]=g.v[i];
        }
    }
    ~gestiune()
    {
        delete []vect;
    }
    friend istream& operator>>(istream& in,gestiune <T> &g)
    {
        cout<<"Introduceti numarul de locuinte: ";

        in>>g.nr;
        cout<<endl;
        g.vect=new T[g.nr];
        for(int i=0; i<g.nr; i++)
        {
            cout<<"Locuinta "<<i+1<<":"<<endl;
            string buff;
            getline(cin,buff);
            in>>g.vect[i];
            cout<<endl;
//                Vector.push_back(make_pair(g.vect[i],"buna"));
        }

        return in;
    }
    friend ostream& operator<<(ostream& out, gestiune<T> &g)
    {
        out<<"S-au vandut "<<g.nr<<" locuinte ";
        for(int i=0; i<g.nr; i++)
        {
            out<<endl<<endl;
            out<<i+1<<":";
            out<<g.vect[i];

        }
        return out;


    }
    /***  int operator+=(locuinta&l)
    //    {
    //        vect.push_back(l);
    //
    //        return ret_nrloc();
    //    }
    //T& operator+=(T& rhs) // compound assignment (does not need to be a member,
    //  {                           // but often is, to modify the private members)
    //    /* addition of rhs to *this takes place here */
//    index++;
//    cin>>rhs;
//        vect.push_back(rhs);
//    return rhs; // return the result by reference
//  }

};

template<>class gestiune<casa>
{
    casa* c;
    int nrcase;
    double profit;
public:
    gestiune(casa* a=NULL,int nr=0)
    {
        nrcase=nr;
        profit=0;
        c=new casa[nrcase];
        for(int i=0; i<nrcase; i++)
        {
            c[i]=a[i];
            profit+=c[i].chirie(c[i]);
        }

    }
    ~gestiune()
    {
        delete [] c;
    }
    gestiune(const gestiune &s)
    {
        /// cout<<"copy specializare";
        nrcase=s.nrcase;
        c=new casa[nrcase];
        for(int i=0; i<nrcase; i++)
            c[i]=s.c[i];
    }
    friend istream& operator>>(istream &in,gestiune<casa> &cg)
    {
        cout<<"Introduceti numarul de case: ";
        in>>cg.nrcase;
        cg.c=new casa[cg.nrcase];
        for(int i=0; i<cg.nrcase; i++)
        {
            cout<<"Casa "<<i+1<<":"<<endl;
            string buf;
            getline(cin,buf);
            in>>cg.c[i];
            cg.profit+=cg.c[i].chirie(cg.c[i]);
            cout<<endl;
        }
        return in;
    }
    friend ostream& operator<<(ostream& out,gestiune<casa> &cg)
    {
        out<<"Au fost vandute "<<cg.nrcase<<" case"<<endl;
        out<<"Profitul agentiei este de: "<<cg.profit;
        return out;

    }

};
void menu_output()
{
    cout<<"Apostol Claudia grupa 211 - tema 9"<<endl;
    cout<<endl<<"MENIU"<<endl;
    cout<<"---------------------------------------"<<endl;
    cout<<endl;
    cout<<"1. Citirea a n locuinte folosind upcast si late-binding"<<endl;
    cout<<"2. Template -> locuinta"<<endl;
    cout<<"3. Template -> apartament"<<endl;
    cout<<"4. Template -> casa (specializare)"<<endl;
    cout<<"5. Citirea a n locuinte cu ajutorul structurii de date vector <pair <locuinta,tip> > "<<endl;
    cout<<"6."<<endl;
    cout<<"7. Contorizare locuinte "<<endl;
    cout<<"0. Iesire"<<endl;
}
void menu()
{
    int option,nr1,ok;
    locuinta **l;
    do
    {
        menu_output();
        cout<<"Introduceti numarul actiunii: ";
        cin>>option;
        if(option>7||option<0)
            cout<<"Selectie invalida"<<endl;
        if(option==0)
            cout<<"EXIT"<<endl;
        if(option==1)
        {
            cout<<endl<<"Introduceti numarul de locuinte citite: ";
            cin>>nr1;
            try
            {
                l=new locuinta*[nr1];
                cout<<endl;
                for(int i=0; i<nr1; i++ )
                {
                    cout<<i+1<<": ";
                    tip(l[i],i);
                    cout<<endl;
                }
            }
            catch(bad_alloc var)
            {
                cout<<"bad alloc"<<endl;
                exit(EXIT_FAILURE);
            }
            ok=1;
            cout<<endl;
            for(int i=0; i<nr1; i++)
            {
                cout<<i+1<<":"<<endl;
                cout<<*l[i];
                cout<<endl;
            }
        }
        if(option==2)
        {
            gestiune<locuinta> x;
            cin>>x;
            //x.afis_vect(x);

            cout<<x;
            //delete &x;
        }
        if(option==3)
        {
            gestiune <apartament>x;
            cin>>x;
            cout<<x;

        }
        if(option==4)
        {
            gestiune<casa> x;
            cin>>x;
            cout<<x;
        }
        if(option==5)
        {
            int nr;
            cout<<"Introduceti numarul de locuinte: ";
            cin>>nr;
            string aux;
            cout<<endl;
            vector<pair<locuinta*, string> > pair_array;
            for(int i=0; i<nr; i++)
            {
                cout<<"Introduceti tipul locuintei "<<i+1<<" (apartament/casa): ";
                cin>>aux;
                string aux1;
                getline(cin, aux1);
                if(aux=="apartament")
                {
                    apartament *ap = new apartament();
                    cin >> *ap;

                    pair_array.emplace_back(make_pair(ap, "apartament"));
                }

                else
                {
                    if(aux=="casa")
                    {
                        casa *c = new casa();
                        cin >> *c;
                        pair_array.emplace_back(make_pair(c, "casa"));
                    }
                    else
                        cout<<"Tip invalid";
                }
                cout<<endl;
            }
            int cont = 0;
            for(auto it = pair_array.begin() ; it != pair_array.end(); ++it)
            {
                cont ++;

                cout<<"Locuinta "<<cont<<" este de tipul: "<<it->second;
                cout << *(it -> first) << endl ;//<< it -> second << endl;
            }


        }
        if(option==6)
        {
//            gestiune <apartament> x;
//            cin>>x;
//            x.get_index();
//            gestiune<apartament> ap;
//            cin>>ap;
//            x+=ap;
//            x.get_index();
//            cout<<x;
//            cout<<endl;
        }
        if(option==7)
        {
            if(ok==1)
            {
                int nr_case=0,nr_ap=0;
                for(int i=0; i<nr1; i++)
                {
                    apartament *a=dynamic_cast<apartament*>(l[i]);
                    casa *c=dynamic_cast<casa*>(l[i]);
                    if(a)
                        nr_ap++;
                    if(c)
                        nr_case++;

                }
                cout<<endl<<"Au fost create "<<nr1<<" locuinte dintre care "<<nr_ap<<" apartamente si "<<nr_case<<" case"<<endl;
            }
            else
                cout<<"Trebuie efectuata mai intai citirea. Intoarce-te la 1."<<endl;
        }
        system("pause");
        system("cls");
    }
    while(option!=0);

}
int main()
{
    menu();
    return 0;
}
